name = "CloseDealOrder success"
sighashes = [investor, fundraiser]
result = pass

signer = Signer!(fundraiser)

let add_ask_order_guid = Guid::random();
let add_bid_order_guid = Guid::random();
let add_offer_guid = Guid::random();
let add_deal_order_guid = Guid::random();

let register_address_investor = register_address_for("investoraddress");
let (investor_address_id, investor_address) = tse.state_entry_from(register_address_investor, SigHash!(investor));

let register_address_fundraiser = register_address_for("fundraiseraddress");
let (fundraiser_address_id, fundraiser_address) = tse.state_entry_from(register_address_fundraiser, SigHash!(fundraiser));

let add_ask_order = AddAskOrder {
    address_id: investor_address_id.into(),
    amount_str: "1000".into(),
    interest: "100".into(),
    maturity: "10".into(),
    fee_str: "1".into(),
    expiration: 10000.into(),
};
let (ask_order_id, ask_order) = tse.state_entry_from(add_ask_order, AddAskOrderArgs {
    guid: add_ask_order_guid,
    address: investor_address,
    sighash: SigHash!(investor),
});

let add_bid_order = AddBidOrder {
    address_id: fundraiser_address_id.into(),
    amount_str: "1000".into(),
    interest: "100".into(),
    maturity: "10".into(),
    fee_str: "1".into(),
    expiration: 10000.into(),
};
let (bid_order_id, bid_order) = tse.state_entry_from(add_bid_order, AddBidOrderArgs {
    guid: add_bid_order_guid,
    address: fundraiser_address,
    sighash: SigHash!(fundraiser),
});

let add_offer = AddOffer {
    ask_order_id: ask_order_id.into(),
    bid_order_id: bid_order_id.into(),
    expiration: 10000.into(),
};
let (offer_id, offer) = tse.state_entry_from(add_offer, AddOfferArgs {
    src_address: investor_address,
    sighash: SigHash!(investor)
});

let add_deal_order = AddDealOrder {
    offer_id: offer_id.into(),
    expiration: 10000.into(),
};

let (deal_order_id, deal_order) = tse.state_entry_from(add_deal_order, AddDealOrderArgs {
    bid_order,
    ask_order,
    offer,
    sighash: SigHash!(fundraiser)
});

let register_transfer_invest = RegisterTransfer {
    gain: 0.into(),
    order_id: deal_order_id.into(),
    blockchain_tx_id: s"blockchaintxid",
};

let (invest_transfer_id, invest_transfer) = tse.state_entry_from(
    register_transfer_invest,
    RegisterTransferArgs {
        kind: TransferKind::DealOrder(deal_order),
        src_address: investor_address,
        src_sighash: SigHash!(investor),
    }
);

let complete_deal_order = CompleteDealOrder {
    deal_order_id: deal_order_id.into(),
    transfer_id: invest_transfer_id.into()
};

let (_id, updated_deal_order) = tse.state_entry_from(complete_deal_order, CompleteDealOrderArgs { deal_order });


let updated_transfer = crate::protos::Transfer {
    processed: true,
    ..invest_transfer
};

let lock_deal_order = LockDealOrder {
    deal_order_id: deal_order_id.into(),
};

let locked_deal_order = crate::protos::DealOrder {
    lock: fundraiser.to_string(),
    ..updated_deal_order
};

rust { tse.inc_tip(); }

let ticks = rust { BlockNum::from((((tse.tip() - 1) - u64::from_str(&updated_deal_order.block).unwrap())
                    + u64::from_str(&updated_deal_order.maturity).unwrap())
                    / u64::from_str(&updated_deal_order.maturity).unwrap()) };
let gain_amount = crate::handler::utils::calc_interest(&CurrencyAmount::try_parse(&deal_order.amount).unwrap(), ticks.into(), &CurrencyAmount::try_parse(&deal_order.interest).unwrap());

let register_transfer_repayment = RegisterTransfer {
    gain: gain_amount.into(),
    order_id: deal_order_id.into(),
    blockchain_tx_id: s"repaymenttxid",
};

let (repayment_transfer_id, repayment_transfer) = tse.state_entry_from(register_transfer_repayment, RegisterTransferArgs {
    kind: TransferKind::DealOrder(locked_deal_order),
    src_address: fundraiser_address,
    src_sighash: SigHash!(fundraiser),
});

let updated_repayment_transfer = crate::protos::Transfer {
    processed: true,
    ..repayment_transfer
};

let closed_deal_order = crate::protos::DealOrder {
    repayment_transfer: repayment_transfer_id.into(),
    ..locked_deal_order
};

rust { tse.inc_tip(); }

command = CloseDealOrder {
    deal_order_id: deal_order_id.into(),
    transfer_id: repayment_transfer_id.into(),
};

require(
    Wallet for investor with amount = rust { tx_fee.clone() * 5 },
    Wallet for fundraiser with amount = rust { tx_fee.clone() * 6 + 1 },
    send transaction { register_address_investor } with signer = Signer!(investor),
    send transaction { register_address_fundraiser } with signer = Signer!(fundraiser),
    send transaction { add_ask_order } with signer = Signer!(investor), guid = add_ask_order_guid,
    send transaction { add_bid_order } with signer = Signer!(fundraiser), guid = add_bid_order_guid,
    send transaction { add_offer } with signer = Signer!(investor), guid = add_offer_guid,
    send transaction { add_deal_order } with signer = Signer!(fundraiser),
    send transaction { register_transfer_invest } with signer = Signer!(investor),
    send transaction { complete_deal_order } with signer = Signer!(investor),
    send transaction { lock_deal_order } with signer = Signer!(fundraiser),
    send transaction { register_transfer_repayment } with signer = Signer!(fundraiser),
)


expect(
    sighash -> fundraiser,
    guid -> Guid!(command),
    get balance at WalletId!(fundraiser) -> rust { tx_fee.clone() },
    get state at deal_order_id -> locked_deal_order,
    get state at repayment_transfer_id -> repayment_transfer,
    get state at invest_transfer_id -> updated_transfer,
    set states {
        deal_order_id : closed_deal_order.to_bytes(),
        repayment_transfer_id : updated_repayment_transfer.to_bytes(),
        WalletId!(fundraiser) : wallet_with(Some(0)).unwrap(),
        make_fee(&Guid!(command), &fundraiser, Some(rust { tse.tip() - 1 }))
    },
)