name = "CompleteRepaymentOrder success"
sighashes = [investor, fundraiser, collector]
result = pass

signer = Signer(investor)
request = TpProcessRequest { tip: 14, ..default }

let investor_address_id = address_id_for("investoraddress")
let fundraiser_address_id = address_id_for("fundraiseraddress")
let collector_address_id = address_id_for("collectoraddress")
let register_address_investor = register_address_for("investoraddress");
let register_address_fundraiser = register_address_for("fundraiseraddress");
let register_address_collector = register_address_for("collectoraddress");


let investor_address = address_for("investoraddress", &Sighash(investor));
let fundraiser_address = address_for("fundraiseraddress", &Sighash(fundraiser));
let collector_address = address_for("collectoraddress", &Sighash(collector));

let add_ask_order = AddAskOrder {
    address_id: investor_address_id.into(),
    amount_str: "1000".into(),
    interest: "100".into(),
    maturity: "10".into(),
    fee_str: "0".into(),
    expiration: 10000.into(),
};

let add_ask_order_guid = Guid();
let ask_order_id = Address::with_prefix_key(ASK_ORDER, add_ask_order_guid.as_str());
let ask_order = crate::protos::AskOrder {
    blockchain: investor_address.blockchain.clone(),
    address: add_ask_order.address_id.clone(),
    amount: add_ask_order.amount_str.clone(),
    interest: add_ask_order.interest.clone(),
    maturity: add_ask_order.maturity.clone(),
    fee: add_ask_order.fee_str.clone(),
    expiration: add_ask_order.expiration.into(),
    block: rust { (request.tip - 8).to_string() },
    sighash: investor.into()
};

let add_bid_order = AddBidOrder {
    address_id: fundraiser_address_id.into(),
    amount_str: "1000".into(),
    interest: "100".into(),
    maturity: "10".into(),
    fee_str: "0".into(),
    expiration: 10000.into(),
};

let add_bid_order_guid = Guid();
let bid_order_id = Address::with_prefix_key(BID_ORDER, add_bid_order_guid.as_str());
let bid_order = crate::protos::BidOrder {
    blockchain: fundraiser_address.blockchain.clone(),
    address: fundraiser_address_id.into(),
    amount: add_bid_order.amount_str.clone(),
    interest: add_bid_order.interest.clone(),
    maturity: add_bid_order.maturity.clone(),
    fee: add_bid_order.fee_str.clone(),
    expiration: add_bid_order.expiration.into(),
    block: rust { (request.tip - 7).to_string() },
    sighash: fundraiser.into()
};



let add_offer = AddOffer {
    ask_order_id: ask_order_id.into(),
    bid_order_id: bid_order_id.into(),
    expiration: 10000.into(),
};

let add_offer_guid = Guid();
let offer_id = Address::with_prefix_key(OFFER, rust { &string!(&ask_order_id, &bid_order_id) });
let offer = crate::protos::Offer {
    blockchain: investor_address.blockchain.clone(),
    ask_order: ask_order_id.into(),
    bid_order: bid_order_id.into(),
    expiration: add_offer.expiration.into(),
    block: rust { (request.tip - 6).to_string() },
    sighash: investor.to_string(),
};


let add_deal_order = AddDealOrder {
    offer_id: offer_id.into(),
    expiration: 10000.into(),
};

let deal_order_id = Address::with_prefix_key(DEAL_ORDER, &offer_id);
let deal_order = crate::protos::DealOrder {
    blockchain: offer.blockchain,
    src_address: ask_order.address,
    dst_address: bid_order.address,
    amount: bid_order.amount,
    interest: bid_order.interest,
    maturity: bid_order.maturity,
    fee: bid_order.fee,
    expiration: add_ask_order.expiration.into(),
    sighash: fundraiser.to_string(),
    block: rust { (request.tip - 5).to_string() },
    ..default
}


let register_transfer = RegisterTransfer {
    gain: 0.into(),
    order_id: deal_order_id.into(),
    blockchain_tx_id: s"blockchaintxid",
};

let transfer_id =  
    Address::with_prefix_key(
        TRANSFER, 
        rust { &string!(&investor_address.blockchain, &register_transfer.blockchain_tx_id, &investor_address.network) }
    );

let transfer = crate::protos::Transfer {
    blockchain: investor_address.blockchain.clone(),
    dst_address: fundraiser_address_id.to_string(),
    src_address: investor_address_id.to_string(),
    order: register_transfer.order_id.clone(),
    amount: deal_order.amount,
    tx: register_transfer.blockchain_tx_id.clone(),
    sighash: investor.to_string(),
    block: rust { (request.tip - 4).to_string() },
    processed: false,
};

let complete_deal_order = CompleteDealOrder {
    deal_order_id: deal_order_id.into(),
    transfer_id: transfer_id.into()
};

let updated_deal_order = crate::protos::DealOrder {
    loan_transfer: transfer_id.into(),
    block: rust { (request.tip - 3).to_string() },
    ..deal_order
}

let updated_transfer = crate::protos::Transfer {
    processed: true,
    ..transfer
};


let add_repayment_order_guid = Guid();
let repayment_order_id = Address::with_prefix_key(REPAYMENT_ORDER, &add_repayment_order_guid);

let add_repayment_order = AddRepaymentOrder {
    deal_order_id: deal_order_id.into(),
    address_id: collector_address_id.into(),
    amount_str: s"100",
    expiration: 10000.into()
}
let repayment_order = crate::protos::RepaymentOrder {
    blockchain: collector_address.blockchain,
    src_address: collector_address_id.into(),
    dst_address: deal_order.src_address,
    amount: add_repayment_order.amount_str,
    expiration: add_repayment_order.expiration.into(),
    block: rust { (request.tip - 2).to_string() },
    deal: add_repayment_order.deal_order_id,
    sighash: collector.into(),
    ..default
};

let complete_repayment_order = CompleteRepaymentOrder {
    repayment_order_id: repayment_order_id.into(),
};

let updated_repayment_order = crate::protos::RepaymentOrder {
    previous_owner: investor.clone().into(),
    ..repayment_order
};

let completed_repayment_deal_order = crate::protos::DealOrder {
    lock: investor.into(),
    ..updated_deal_order
}

command = complete_repayment_order;

require(
    Wallet for investor with amount = rust { tx_fee.clone() * 6 },
    Wallet for fundraiser with amount = rust { tx_fee.clone() * 3 },
    Wallet for collector with amount = rust { tx_fee.clone() * 3 },
    Guid for add_ask_order,
    Guid for add_bid_order,
    send transaction { register_address_investor } with signer = Signer(investor),
    send transaction { register_address_fundraiser } with signer = Signer(fundraiser),
    send transaction { register_address_collector } with signer = Signer(collector),
    send transaction { add_ask_order } with signer = Signer(investor), guid = add_ask_order_guid,
    send transaction { add_bid_order } with signer = Signer(fundraiser), guid = add_bid_order_guid,
    send transaction { add_offer } with signer = Signer(investor), guid = add_offer_guid,
    send transaction { add_deal_order } with signer = Signer(fundraiser),
    send transaction { register_transfer } with signer = Signer(investor),
    send transaction { complete_deal_order } with signer = Signer(investor),
    send transaction { add_repayment_order } with signer = Signer(collector), guid = add_repayment_order_guid,
)


expect(
    sighash -> investor,
    guid -> Guid(command),
    get balance at WalletId(investor) -> rust { tx_fee.clone() },
    get state at deal_order_id -> updated_deal_order,
    get state at repayment_order_id -> repayment_order,
    get state at investor_address_id -> investor_address,
    set states {
        repayment_order_id : updated_repayment_order.to_bytes(),
        deal_order_id : completed_repayment_deal_order.to_bytes(),
        WalletId(investor) : wallet_with(Some(0)).unwrap(),
        make_fee(&Guid(command), &investor, Some(rust { request.tip - 1 }))
    },
)