name = "RegisterAddress success";
sighashes = [investor];
result = pass;

signer = Signer!(investor);

let register_address = RegisterAddress {
    blockchain: "ethereum".into(),
    address: "myaddress".into(),
    network: "rinkeby".into(),
};
let (address_id, address) = tse.state_entry_from(register_address, SigHash!(investor));

command = register_address;

require(
    Wallet for investor with amount = tx_fee,
);

let guid = Guid!(command);
expect(
    sighash -> investor,
    guid -> Guid!(command),
    get balance at WalletId!(investor) -> Some(tx_fee),
    get state at address_id -> None, 
    set states {
        address_id.to_string() : address.to_bytes(),
        WalletId!(investor) :  wallet_with(Some(0)).unwrap(),
        make_fee(&guid, &investor, Some( rust { tse.tip() - 1 }))
    }
);

---

name = "RegisterAddress taken";
sighashes = [investor, fundraiser];
result = fail(err = "The address has been already registered");

signer = Signer!(investor);

let register_address = RegisterAddress {
    blockchain: "ethereum".into(),
    address: "myaddress".into(),
    network: "rinkeby".into(),
};

let (address_id, address) = tse.state_entry_from(register_address, SigHash!(fundraiser));

command = register_address;

require(
    Wallet for investor with amount = tx_fee,
    Wallet for fundraiser with amount = tx_fee,
    send transaction { register_address } with signer = Signer!(fundraiser),
);

expect(
    sighash -> SigHash!(investor),
    get balance at WalletId!(investor) -> tx_fee,
    get state at address_id -> Some(address),
);