name = "RegisterAddress success";
sighashes = [my_sighash];
command = RegisterAddress {
    blockchain: "ethereum".into(),
    address: "myaddress".into(),
    network: "rinkeby".into(),
};
signer = Signer!(my_sighash);
result = pass;
request = TpProcessRequest {
    tip: 2,
    ..default
};

require(
    Wallet for my_sighash with amount = tx_fee,
    Guid for command
);

let address_proto = rust { crate::protos::Address {
        blockchain: command.blockchain.clone(),
        value: command.address.clone(),
        network: command.network.clone(),
        sighash: my_sighash.to_string(),
    }
};
let address = rust { AddressId::with_prefix_key(crate::handler::constants::ADDR, &string!("ethereum", "myaddress", "rinkeby")) };

let guid = Guid!(command);
expect(
    sighash -> my_sighash,
    guid -> Guid!(command),
    get balance at WalletId!(my_sighash) -> Some(tx_fee),
    get state at address -> None, 
    set states {
        address.to_string() : address_proto.to_bytes(),
        WalletId!(my_sighash) : rust { wallet_with(Some(0)).unwrap() },
        rust { make_fee(&guid, &my_sighash, Some(1)) }
    }
);

---

name = "RegisterAddress taken";
sighashes = [my_sighash, other_sighash];
command = RegisterAddress {
    blockchain: "ethereum".into(),
    address: "myaddress".into(),
    network: "rinkeby".into(),
};
signer = Signer!(my_sighash);
result = fail(err = "The address has been already registered");

request = TpProcessRequest {
    tip: 2,
    ..default
};

let address_proto = crate::protos::Address {
    blockchain: command.blockchain.clone(),
    value: command.address.clone(),
    network: command.network.clone(),
    sighash: my_sighash.to_string(),
};
let address = rust { 
    AddressId::with_prefix_key(crate::handler::constants::ADDR, &string!("ethereum", "myaddress", "rinkeby")) 
};


require(
    Wallet for my_sighash with amount = tx_fee,
    Wallet for other_sighash with amount = tx_fee,
    Guid for command,
    send transaction { command.clone() } with signer = Signer!(other_sighash),
);

expect(
    sighash -> my_sighash,
    get balance at WalletId!(my_sighash) -> tx_fee,
    get state at address -> Some(address_proto),
);